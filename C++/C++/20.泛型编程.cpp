/*
 * @file   20.泛型编程.cpp
 * @date   2019.3.12.
 * @author GBW
 * @Description: 
 
 * @Note:
 
 */
0. 对象编程关注编程的数据方面
0. 泛型编程关注算法，泛型旨在编写独立于数据类型的代码
0. 模板提供了存在在容器中的数据类型的通用表示，因此还需要遍历容器中的值的通用表示，迭代器就是这样的通用表示。

1. 超尾标记: 每个容器类都有一个超尾标记，当迭代器递增到超越容器的最后一个值后，这个值将被赋给迭代器。每个容器类都有
	        begin()和end()方法，分别返回一个指向容器的第一个元素和超尾位置的迭代器。

2. 迭代器类型
	1. 输入迭代器:“输入”是从程序角度说的，即来自容器的信息被视为输入
		0. 输入迭代器的算法不会修改容器中的值
		1. 输入迭代器被递增后，也不能保证其先前的值仍然可以被解除引用
		2. 基于输入迭代器的任何算法都应当是单通行的，不依赖于前一次遍历时的迭代器，也不依赖于本次遍历中前面的迭代器值
		3.cin>>

	2. 输出迭代器:“输出”是指用于将信息从程序传输给容器的迭代器，因此程序的输出就是容器的输入
		0.cout<<

	3. 正向迭代器:只使用++运算符来遍历容器，所以每次沿容器向前移动一个元素
		0. 总是按相同的顺序遍历一系列值
		1. 将正向迭代器递增后，仍然可以对前面的迭代器值解除引用，并可以得到相同的值

	4. 双向迭代器:具有正向迭代器的所有特性，同时支持(前缀和后缀)递减运算符

	5. 随机访问迭代器:具有双向迭代器的所有特性，同时添加了支持随机访问的操作和用于对元素进行排序的关系运算

/* 
	rbegin()和end()返回相同的值(超尾)，但类型不同(reverse_iterator和iterator).
	同样，rend()和begin()也返回相同的值(指向第一个元素的迭代器)，但类型不同.
	必须对反向指针做特殊补偿，假设 rp = vector.rbegin(),因为rbegin()返回超尾，故不能对该地址进行解除引用。
	反向指针通过先递减再解除引用，解决此问题。即*rp将在*rp的当前值之前对迭代器执行解除引用。
	即若rp指向6，则*rp将是位置5的值。

*/

3.容器类型
	1. vector
		0.是数组的一种类表示，提供了自动内存管理功能。
		1.可以动态得改变vector对象的长度，并随着元素的添加和删除而增大和缩小
		2.提供了对元素的随机访问，在尾部添加和删除元素的时间是固定的，但在头部或中间插入和删除元素的复杂度为线性时间
		3.a.erase(p) // 删除p指向的元素
		4.a.erase(p, q) // 删除区间[p,q)中的元素
		5.a.clear() // 等价于earse(begin(), end())
	2. deque. 双端队列
		0.支持随机访问
		1.对qeue对象的开始位置插入和删除元素的时间是固定的，而不像vector是线性时间，
		  所以如果多数操作发发生在序列的起始和结尾处，则应考虑deque
	3. list. 双向链表
		0.list和vector之间的区别在:list在链表中任意位置插入和删除的时间都是固定的
		  vector强调通过随机访问快速访问
		  list强调元素的快速插入和删除
		1. list不支持数组表示法和随机访问
		2.void merge(list<T, Alloc>& x）// 将链表x与调用链表合并，两个链表必须已经排序，合并后的经过排序的链表保存在调用链表中，x为空
		3.void remove(const T& val)     // 从链表中删除所有val的实例
		4.void sort()
		5.void splice(iterator pos, list<T, Alloc>x) // 将链表x的内容插入到pos的前面，x将为空
		6.void unique()                 // 将连续的相同元素压缩为单个元素,只能将相邻的相同值压缩为单个值
	4. forward_list. 单链表

	5. queue
		0.queue模板的限制比deque更多，不仅不允许随机访问队列元素，甚至不允许遍历队列
		1.可将元素添加到对尾、从对首删除元素、查看对首和对尾的值、检查元素数目和测试队列是否为空
		2.bool empty() const // 如果队列为空，则返回true
		3.T& front()         // 返回指向对首元素的引用
		4.T& back()
		5.void push(const T& x) // 在对尾插入x
		6.void pop()            // 删除对首元素
	6.priority_queue
		0.最大的元素被移动到对首
		1.默认的底层内是vector
	7.stack
		0.不允许随机访问栈元素，甚至不允许遍历栈
		1.只可以压栈、出栈、查看栈顶的值、检查元素数目和测试栈是否为空
	8. array

4.关联容器
	1.set
		0.可反转、排序、且键唯一的，所以不能存储多个相同的值
	2.multimap
		0.可反转、排序，但是键和值的类型不同，且同一个键可能与多个值相关联














