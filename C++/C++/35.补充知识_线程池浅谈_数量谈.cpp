/*
 * @file   35.补充知识_线程池浅谈_数量谈.cpp
 * @date   2019.3.23.
 * @author GBW
 * @Description: 
 
 * @Note:
 
 */

0. 虚假唤醒wait(), notify_one(), notify_all()
wait中要有第二参数(lambda)并且这个lambda中要正确判断要处理的公共数据是否存在


1. atomic
atomic<int> atom;
cout << atom << endl; // 读atom是个原子操作，但是整个这一行代码并不是个原子操作
class A {
public:
	atomic<int> atm;
	A()
	{
		atm = 0;
		auto atm2 = atm; // 这种定义时初始化操作不允许，显示"尝试引用已删除的函数"编译器内部肯定把拷贝构造函数给干掉了用 = delete
		atomic<int> atm3 = atm; // 不允许
		atm2 = atm; // 尝试引用已经删除的函数，拷贝赋值运算符也不让用
		// laod(); 以原子方式读atomic对象的值
		atomic<int> atm2(atm.load());
		auto atm3(atm.load());

		// store(); // 以原子方式写入内容
		atm2.store(12);
		atm2 = 12;
 	}
};

2. 线程池
	0. 场景
	// 服务器程序->客户端， 每来一个客户端，就创建一个新线程为该客户服务
	// 1)网络游戏， 2万玩家不能给每个玩家创建个新线程，此种程序写法在这种场景下不通
	// 2)程序稳定性问题：编写的代码中，偶尔创建一个新线程这种代码，写法非常不安全
	1. 线程池
	// 把一堆线程弄到一起，同一管理。这种同一管理调度，循环利用线程的范式，就叫线程池
	// 程序启动时，一次性的创建好一定数量的线程，


3. 线程创建数量
	0. 线程开的数量极限问题，2000个线程基本就是极限，再创建程序就奔溃
	1. 线程创建数量的建议
		0. 采用某些技术开发程序，api接口提供商建议你，就按照专业建议和指示来
		1. 创建多个线程完成业务，一个线程等于一条执行道路

4. C++11多线程总结
	Windows,linux:
